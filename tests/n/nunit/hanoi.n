# Copyright 2013 the Neutrino authors (see AUTHORS).
# Licensed under the Apache License, Version 2.0 (see LICENSE).

import $assert;
import $core;

## The instance manager for this process. The whole instance manager model is
## pretty tentative at the moment so this will inevitably change.
def @manager := @ctrino.new_instance_manager(null);

## An individual hanoi disk.
type @HanoiDisk {

  ## Getter for the size property.
  def $this.size => @size_field[$this];

  ## Getter and setter for the next property.
  def $this.next => @next_field[$this];
  def $this.next := ($value) => (@next_field[$this] := $value);

}

def @size_field := module.new_global_field("HanoiDisk.size");
def @next_field := module.new_global_field("HanoiDisk.next");

## Creates a new mutable hanoi disk with the given size.
def ($this == @HanoiDisk).new(size: $size) {
  def $self := @manager.new_instance(@HanoiDisk);
  @size_field[$self] := $size;
  $self;
}

## Holds the state of the hanoi system.
type @Hanoi {

  ## The Hanoi.piles field.
  def $this.piles => @piles_field[$this];
  def $this.piles := ($value) => (@piles_field[$this] := $value);

  ## The Hanoi.moves field.
  def $this.moves => @moves_field[$this];
  def $this.moves := ($value) => (@moves_field[$this] := $value);

  ## Runs the hanoi algorithm starting from a stack of $size disks on the first
  ## pile.
  def $this.run(size: $size) {
    $this.build(pile: 0, disks: $size);
    $this.move(from: 0, to: 1, disks: $size);
    $this.moves;
  }

  ## Move $disks disks from $from to $to, possibly using the third pile as an
  ## intermediate. Increments the .moves field by the number of steps taken.
  def $this.move(from: $from, to: $to, disks: $disks) {
    if $disks == 1 then {
      $this.move_top($from, $to);
    } else {
      # For any $to and $from different and between 0 and 2 this happens to yield
      # the third value between 0 and 2 different from both of the others.
      def $other := (3 - $from) - $to;
      $this.move($from, $other, $disks - 1);
      $this.move_top($from, $to);
      $this.move($other, $to, $disks - 1);
    }
  }

  ## Moves the top disk from $from to $to.
  def $this.move_top($from, $to) {
    def $disk := $this.pop($from);
    $this.push($to, $disk);
    $this.moves := $this.moves + 1;
  }

  ## Removes the top disk from the given pile.
  def $this.pop($pile) {
    def $top := ($this.piles)[$pile];
    ($this.piles)[$pile] := $top.next;
    $top.next := null;
    $top;
  }

  ## Places the given disk op top of the given pile.
  def $this.push($pile, $disk) {
    def $top := ($this.piles)[$pile];
    $disk.next := $top;
    ($this.piles)[$pile] := $disk;
  }

  ## Build a stack of $disks disks on pile $pile.
  def $this.build(pile: $pile, disks: $disks) {
    for $i in (0).to($disks) do {
      def $size := $disks - $i - 1;
      def $disk := new @HanoiDisk(size: $size);
      $this.push($pile, $disk);
    }
  }

}

def @piles_field := module.new_global_field("Hanoi.piles");
def @moves_field := module.new_global_field("Hanoi.moves");

## Creates a new empty hanoi instance.
def ($this == @Hanoi).new() {
  def $self := @manager.new_instance(@Hanoi);
  $self.piles := @core:Array.new(3);
  $self.moves := 0;
  $self;
}

def $test_hanoi() {
  def $hanoi := new @Hanoi();
  def $moves := $hanoi.run(size: 9);
  # Verify that the algorithm took 2^n-1 steps as expected.
  $assert:equals(511, $moves);
}

do {
  $test_hanoi();
}
